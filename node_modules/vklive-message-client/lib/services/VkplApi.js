import { EventEmitter } from "eventemitter3";
import VKPLMessageClient from "../client.js";
import { DeferredPromise, sleep } from "../utils/index.js";
export class VkplApi extends EventEmitter {
    messageParser;
    auth;
    baseUrl;
    refreshTokenPromise;
    refreshTokenTimeout;
    constructor(messageParser, auth, baseUrl = "https://api.live.vkvideo.ru/v1") {
        super();
        this.messageParser = messageParser;
        this.auth = auth;
        this.baseUrl = baseUrl;
        if (auth && "refreshToken" in auth) {
            const untilExpiration = auth.expiresAt - VkplApi.tokenExpiresShift - Date.now();
            this.refreshTokenTimeout = setTimeout(() => this.refreshToken().catch(console.error), untilExpiration);
        }
    }
    addAuthorizationHeader(headers) {
        if (!this.auth) {
            return;
        }
        if (!headers.has("Authorization")) {
            headers.append("Authorization", `Bearer ${this.auth.accessToken}`);
        }
        if ("clientId" in this.auth) {
            headers.set("X-From-Id", this.auth.clientId);
        }
    }
    /**
     * Получить закреплённое сообщение в чате
     *
     * @param channel - название канала
     */
    async getPinMessage(channel) {
        const res = await this.httpRequest(`/channel/${channel}/public_video_stream/chat/pinned_message`, "GET");
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res.data.pinnedMessage;
    }
    /**
     * Перманентно закрепляет сообщение в чате
     *
     * @param channel - название канала
     * @param pinSettings - настройки закрепленного сообщения
     */
    async pinMessage(channel, pinSettings) {
        const body = new URLSearchParams({
            kind: pinSettings.kind,
            message_id: pinSettings.messageId.toString(),
            reactable: pinSettings.reactable.toString(),
        });
        const res = await this.httpRequest(`/channel/${channel}/public_video_stream/chat/pinned_message`, "POST", undefined, body.toString(), new Headers({
            "Content-type": "application/x-www-form-urlencoded",
        }));
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    /**
     * Обновляет настройки закрплённого сообщения в чате
     *
     * @param channel - название канала
     * @param pinSettings - настройки закрепленного сообщения
     */
    async updatePinMessage(channel, pinSettings) {
        const body = new URLSearchParams({
            kind: pinSettings.kind,
            reactable: pinSettings.reactable.toString(),
        });
        const res = await this.httpRequest(`/channel/${channel}/public_video_stream/chat/pinned_message`, "PUT", undefined, body.toString(), new Headers({
            "Content-type": "application/x-www-form-urlencoded",
        }));
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    /**
     * Удаляет закреплённое сообщение
     *
     * @param channel - название канала
     */
    async deletePinMessage(channel) {
        const res = await this.httpRequest(`/channel/${channel}/public_video_stream/chat/pinned_message`, "DELETE");
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    /**
     * Получает список смайлов канала
     *
     * @param channel - название канала
     */
    async getSmilesSet(channel) {
        const res = await this.httpRequest(`/blog/${channel}/smile/user_set/`, "GET");
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    /**
     * Получает информацию о блоге
     *
     * @param channel - название канала
     */
    async getBlog(channel) {
        const res = await this.httpRequest(`/blog/${channel}`, "GET");
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    /**
     * Получает информацию о текущем пользователе
     */
    async getCurrentUser() {
        const res = await this.httpRequest("/user/current", "GET");
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    async getWebSocketConnectToken() {
        const res = await this.httpRequest(`/ws/connect`, "GET");
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    async getWebSocketSubscriptionToken(channels) {
        const params = new URLSearchParams({
            channels: channels.map((c) => `channel-info-manage:${c}`).join(","),
        });
        const res = await this.httpRequest("/ws/subscribe", "GET", params);
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    /**
     * Таймаут пользователя
     *
     * @param channel - название канала
     * @param userId - идентификатор пользователя
     * @param seconds - время таймаута в секундах
     */
    async timeoutUser(channel, userId, seconds) {
        const body = new URLSearchParams({
            user_id: userId.toString(),
            period: seconds.toString(),
            by_stream: "flase",
            is_permanent: "false",
        });
        const res = await this.httpRequest(`/blog/${channel}/public_video_stream/ban`, "POST", undefined, body.toString(), new Headers({
            "Content-type": "application/x-www-form-urlencoded",
        }));
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    /**
     * Перманентно блокирует пользователя
     *
     * @param channel - название канала
     * @param userId - идентификатор пользователя
     */
    async banUser(channel, userId) {
        const body = new URLSearchParams({
            user_id: userId.toString(),
            by_stream: "flase",
            clean_messages: "true",
            is_permanent: "true",
        });
        const res = await this.httpRequest(`/blog/${channel}/public_video_stream/ban`, "POST", undefined, body.toString(), new Headers({
            "Content-type": "application/x-www-form-urlencoded",
        }));
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    /**
     * Отменяет таймаут и блокировку пользователя
     *
     * @param channel - название канала
     * @param userId - идентификатор пользователя
     */
    async unbanUser(channel, userId) {
        const query = new URLSearchParams({
            user_id: userId.toString(),
            by_stream: "flase",
        });
        const res = await this.httpRequest(`/blog/${channel}/public_video_stream/ban`, "DELETE", query);
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    /**
     * Удаляет все сообщения пользователя из чата канала
     *
     * @param channel - название канала
     * @param userId - идентификатор пользователя
     */
    async deleteUserMessages(channel, userId) {
        const query = new URLSearchParams({ user_id: userId.toString() });
        const res = await this.httpRequest(`/blog/${channel}/public_video_stream/chat/clean`, "DELETE", query);
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    /**
     * Получает статистику пользователя
     *
     * @param channel - название канала
     * @param userId - идентификатор пользователя
     */
    async userStats(channel, userId) {
        const query = new URLSearchParams({ user_id: userId.toString() });
        const res = await this.httpRequest(`/blog/${channel}/public_video_stream/chat/stat`, "GET", query);
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    /**
     * Получает роли, доступные на канале
     *
     * @param channel - название канала
     */
    async getChannelRoles(channel) {
        const res = await this.httpRequest(`/channel/${channel}/role`, "GET");
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    /**
     * Изменяет роли пользователя
     *
     * @param channel - название канала
     * @param userId - идентификатор пользователя
     * @param roles - список идентификаторов ролей
     */
    async setUserRoles(channel, userId, roles) {
        const body = new URLSearchParams();
        body.append("role_ids", roles.join(","));
        const res = await this.httpRequest(`/channel/${channel}/role/user/${userId}`, "PUT", undefined, body.toString(), new Headers({
            "Content-type": "application/x-www-form-urlencoded",
        }));
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    /**
     * Обновляет информацию о стриме
     *
     * @param channel - название канала
     * @param streamInfo - информация о стриме
     *
     * Параметр `title` будет парситься. Возможно использование ссылок.
     * Параметр `plannedAt` будет переведён в UNIX timestamp
     */
    async setStreamInfo(channel, streamInfo) {
        const body = new URLSearchParams();
        if (streamInfo.title) {
            body.append("title_data", JSON.stringify(this.messageParser.serialize(streamInfo.title)));
        }
        if (streamInfo.categoryId) {
            body.append("category_id", streamInfo.categoryId);
        }
        if (streamInfo.plannedAt) {
            const timestamp = Math.floor(streamInfo.plannedAt.getTime() / 1000);
            body.append("planned_at", timestamp.toString());
        }
        if (streamInfo.donationAlertNick) {
            body.append("da_nick", streamInfo.donationAlertNick);
        }
        if (streamInfo.subscriptionLevelId) {
            body.append("subscription_level_id", streamInfo.subscriptionLevelId);
        }
        const res = await this.httpRequest(`/channel/${channel}/manage/stream`, "PUT", undefined, body.toString(), new Headers({
            "Content-type": "application/x-www-form-urlencoded",
        }));
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    /**
     * Получает список категорий, доступных на live.vkvideo.ru
     *
     * @param filters - Фильтры. Если не указывать фильтры, то возвращает список из всех категорий
     * @return {Promise<APITypes.CategoryResponse>} Ответ API
     */
    async getCategories(filters) {
        const query = new URLSearchParams();
        if (filters?.type) {
            query.append("type", filters.type);
        }
        if (filters?.search) {
            query.append("search", filters.search);
        }
        if (filters?.limit) {
            query.append("limit", filters.limit.toString());
        }
        const res = await this.httpRequest("/public_video_stream/category/", "GET", query);
        if (typeof res === "string") {
            throw new Error(res);
        }
        return res;
    }
    /**
     * Метод производит поиск категории по названию. Если нашлась категория, то производит
     * изменение категории канала.
     *
     * @param channel - Канал
     * @param categoryName - Название категории
     * @return {Promise<APITypes.ManageStreamResponse>} Ответ API на изменение категории
     *
     * @throws {Error} Если категория не найдена
     */
    async setCategory(channel, categoryName) {
        const category = await this.getCategories({
            search: categoryName,
            limit: 1,
        });
        const categoryId = category.data[0]?.id;
        if (!categoryId)
            throw new Error("Category not found");
        return await this.setStreamInfo(channel, {
            categoryId,
        });
    }
    /**
     * @param message - Сообщение
     * @param channel - Канал
     * @param mentionUserId - ID пользователей, которые должны быть упомянуты в сообщении
     * @param threadId - ID сообщения, если нужно ответить в конкретной ветке
     * @return {Promise<APITypes.TMessageResponse>} Ответ API на сообщение
     *
     * Позволяет отправлять сообщение в чат трансляции без подключения к чату. Нужно лишь указать канал, куда будет отправлено сообщение
     */
    async sendMessage(message, channel, mentionUsers, threadId) {
        const serializedMessage = {
            data: JSON.stringify(this.messageParser.serialize(message, mentionUsers)),
        };
        const body = new URLSearchParams(serializedMessage);
        if (threadId) {
            body.set("reply_to_id", threadId.toString());
        }
        const res = await this.httpRequest(`/blog/${channel}/public_video_stream/chat`, "POST", undefined, body.toString(), new Headers({
            "Content-type": "application/x-www-form-urlencoded",
        }));
        if (typeof res === "string") {
            throw new Error(res);
        }
        if (VKPLMessageClient.debugLog)
            console.warn("[debug:send-message] ", JSON.stringify(res, null, 4));
        return res;
    }
    /**
     * @deprecated Vkpl усложнил процесс получения токена по логину и паролю. Поэтому данный функционал временно не работает.
     * При попытке использовать эту функцию, будет выдана ошибка.
     */
    static async login(_username, _password) {
        throw new Error("VkplApi.login() is deprecated. Please use accessToken instead.");
        // const jar = new CookieJar();
        // const agent = new CookieAgent({ cookies: { jar } });
        // const body = new URLSearchParams({
        //     login: username,
        //     password: password,
        // });
        //
        // let res = await fetch("https://auth-ac.vkvideo.ru/sign_in", {
        //     method: "POST",
        //     headers: {
        //         "Content-Type": "application/x-www-form-urlencoded",
        //         origin: "https://account.vkvideo.ru",
        //         referer: "https://account.vkvideo.ru",
        //     },
        //     body: body.toString(),
        //     dispatcher: agent,
        // });
        //
        // if (!res.ok) {
        //     throw new Error("[api] Cannot get token");
        // }
        //
        // res = await fetch(
        //     "https://account.vkvideo.ru/oauth2/?redirect_uri=" +
        //         "https%3A%2F%2Flive.vkvideo.ru%2Fapp%2Foauth_redirect_vkplay&client_id=vkplay.live&response_type=code&skip_grants=1",
        //     {
        //         method: "GET",
        //         headers: {
        //             origin: "https://account.vkvideo.ru",
        //             referer: "https://account.vkvideo.ru",
        //         },
        //         dispatcher: agent,
        //     },
        // );
        //
        // if (!res.ok) {
        //     throw new Error("[api] Cannot get token");
        // }
        //
        // res = await fetch("https://live.vkvideo.ru", {
        //     dispatcher: agent,
        // });
        //
        // if (!res.ok) {
        //     throw new Error("[api] Cannot get token");
        // }
        //
        // const cookies = await jar.getCookies("https://live.vkvideo.ru");
        // const tokenCookie = cookies.find((c) => c.key === "auth");
        //
        // if (!tokenCookie) {
        //     throw new Error("[api] Cannot get token cookie");
        // }
        //
        // const parsedToken = JSON.parse(
        //     decodeURIComponent(tokenCookie.value),
        // ) as APITypes.AuthResponse;
        //
        // return parsedToken;
    }
    static tokenExpiresShift = 10 * 60 * 1000; // 10 min
    isTokenExpired() {
        if (!this.auth) {
            return false;
        }
        if (!("expiresAt" in this.auth)) {
            return false;
        }
        return this.auth.expiresAt - VkplApi.tokenExpiresShift <= Date.now();
    }
    async refreshToken() {
        if (!this.auth) {
            throw new TypeError("Auth must be provided to refresh token");
        }
        if (!("refreshToken" in this.auth))
            throw new TypeError("Refresh token must be provided to refresh token");
        if (this.refreshTokenPromise) {
            return await this.refreshTokenPromise.promise;
        }
        this.refreshTokenPromise = new DeferredPromise();
        try {
            const body = new URLSearchParams({
                response_type: "code",
                refresh_token: this.auth.refreshToken,
                grant_type: "refresh_token",
                device_id: this.auth.clientId,
                device_os: "streams_web",
            });
            const res = await fetch("https://api.live.vkvideo.ru/oauth/token/", {
                method: "POST",
                body: body.toString(),
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    origin: "https://live.vkvideo.ru",
                    referer: "https://live.vkvideo.ru",
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36",
                },
            });
            if (!res.ok)
                throw new Error(`[api] Cannot refresh token: ${await res.text()}`);
            const refreshedToken = (await res.json());
            const token = {
                accessToken: refreshedToken.access_token,
                refreshToken: refreshedToken.refresh_token,
                expiresAt: Date.now() + refreshedToken.expires_in * 1000,
                clientId: this.auth.clientId,
            };
            this.auth.accessToken = token.accessToken;
            this.auth.refreshToken = token.refreshToken;
            this.auth.expiresAt = token.expiresAt;
            this.refreshTokenPromise.resolve(token);
            this.emit("refreshed", token);
            if (this.refreshTokenTimeout) {
                clearTimeout(this.refreshTokenTimeout);
            }
            this.refreshTokenTimeout = setTimeout(() => this.refreshToken().catch(console.error), token.expiresAt - VkplApi.tokenExpiresShift - Date.now());
            return token;
        }
        finally {
            this.refreshTokenPromise = undefined;
        }
    }
    async httpRequest(endpoint, method, query, body, headers = new Headers()) {
        if (this.isTokenExpired()) {
            await this.refreshToken();
        }
        this.addAuthorizationHeader(headers);
        const url = `${this.baseUrl}${endpoint}?${new URLSearchParams(query)}`;
        while (true) {
            const response = await fetch(url, {
                method,
                headers,
                body,
            });
            if (response.status >= 400) {
                try {
                    const error = await response.clone().json();
                    if (this.isCantSendError(error)) {
                        const delay = Math.max(...error.data.reasons
                            .filter((r) => r.type === "slow_mode_cooldown")
                            .map((r) => r.remaningTime));
                        await sleep(delay * 1000);
                        continue;
                    }
                }
                catch {
                    throw new Error(`[api:${response.status}] Error in request: ${await response.clone().text()}`);
                }
                throw new Error(`[api:${response.status}] Error in request: ${await response.clone().text()}`);
            }
            if (response.headers
                .get("Content-Type")
                ?.includes("application/json")) {
                return (await response.json());
            }
            return await response.text();
        }
    }
    isCantSendError(error) {
        return (typeof error === "object" &&
            error !== null &&
            "error" in error &&
            error.error === "cant_send");
    }
}
