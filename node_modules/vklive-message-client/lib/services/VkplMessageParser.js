const markdownLinkRegex = /\[(.*?)\]\((.*?)\)/gm;
export class VkplMessageParser {
    smiles;
    constructor(smiles) {
        this.smiles = smiles;
    }
    static replaceMarkdownLinks(message) {
        const markdownLinks = Array.from(message.matchAll(markdownLinkRegex));
        return [
            message.replaceAll(markdownLinkRegex, (substring) => {
                const index = markdownLinks.findIndex((link) => link[0] === substring);
                return "__markdownLink+" + index.toString() + "__";
            }),
            markdownLinks,
        ];
    }
    serialize(message, mentionIds) {
        const serializedMessage = [];
        if (mentionIds) {
            for (const mentionId of mentionIds) {
                serializedMessage.push(...this.getMentionBlock(mentionId));
            }
        }
        const [messageWithoutMarkdownLinks, markdownLinks] = VkplMessageParser.replaceMarkdownLinks(message);
        const splitedMessage = messageWithoutMarkdownLinks.split(" ");
        let textStack = "";
        for (const word of splitedMessage)
            if (this.smiles.has(word)) {
                if (textStack) {
                    serializedMessage.push(...this.getTextBlock(textStack));
                    textStack = "";
                }
                serializedMessage.push(...this.getSmileBlock(word, this.smiles.get(word) ?? word));
            }
            else if (word.startsWith("https://") ||
                word.startsWith("http://")) {
                if (textStack) {
                    serializedMessage.push(...this.getTextBlock(textStack));
                    textStack = "";
                }
                serializedMessage.push(...this.getLinkBlock(word, word));
            }
            else if (word.startsWith("__markdownLink+") &&
                word.endsWith("__")) {
                const mdlIndex = Number(word.slice("__markdownLink+".length, -2));
                if (!isNaN(mdlIndex) && markdownLinks[mdlIndex]) {
                    if (textStack) {
                        serializedMessage.push(...this.getTextBlock(textStack));
                        textStack = "";
                    }
                    const link = markdownLinks[mdlIndex][2];
                    if (!link) {
                        continue;
                    }
                    const text = markdownLinks[mdlIndex][1] || link;
                    serializedMessage.push(...this.getLinkBlock(link, text));
                }
            }
            else {
                textStack += word + " ";
            }
        if (textStack)
            serializedMessage.push(...this.getTextBlock(textStack));
        return serializedMessage;
    }
    getSmileBlock(word, smileId) {
        return [
            this.getBlockEnd(),
            { type: "smile", id: smileId, name: word },
            this.getBlockEnd(),
        ];
    }
    getTextBlock(text) {
        return [
            {
                type: "text",
                content: JSON.stringify([text, "unstyled", []]),
                modificator: "",
            },
        ];
    }
    getBlockEnd() {
        return { type: "text", content: "", modificator: "BLOCK_END" };
    }
    getMentionBlock(userId) {
        return [
            this.getBlockEnd(),
            { type: "mention", id: userId },
            this.getBlockEnd(),
        ];
    }
    getLinkBlock(link, text) {
        return [
            {
                explicit: false,
                type: "link",
                content: JSON.stringify([text ?? link, "unstyled", []]),
                url: link,
            },
            ...this.getTextBlock(" "),
        ];
    }
    static deserialize(message) {
        const deserializedMessage = {
            smiles: [],
            text: "",
            mentions: [],
            links: [],
        };
        for (const block of message)
            switch (block.type) {
                case "mention":
                    const blockAsBlockMention = block;
                    deserializedMessage.mentions.push({
                        displayName: blockAsBlockMention.displayName,
                        name: blockAsBlockMention.name,
                        nick: blockAsBlockMention.nick,
                        userId: blockAsBlockMention.id,
                    });
                    if (blockAsBlockMention.displayName) {
                        deserializedMessage.text = `${deserializedMessage.text.trim()} ${blockAsBlockMention.displayName}`;
                    }
                    break;
                case "text":
                    deserializedMessage.text = `${deserializedMessage.text.trim()} ${block.content && block.content.length > 0
                        ? JSON.parse(block.content)[0]
                        : ""}`;
                    break;
                case "smile":
                    deserializedMessage.smiles.push(block);
                    deserializedMessage.text = `${deserializedMessage.text.trim()} ${block.name}`;
                    break;
                case "link":
                    deserializedMessage.links.push({
                        text: block.content,
                        url: block.url,
                    });
                    deserializedMessage.text = `${deserializedMessage.text.trim()} ${block.content && block.content.length > 0
                        ? JSON.parse(block.content)[0]
                        : ""}`;
                    break;
                default:
                    break;
            }
        deserializedMessage.text = deserializedMessage.text.trim();
        return deserializedMessage;
    }
}
