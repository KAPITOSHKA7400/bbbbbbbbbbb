import { EventEmitter } from "eventemitter3";
import WebSocket from "ws";
import VKPLMessageClient from "../index.js";
export class CentrifugeClient extends EventEmitter {
    wsServerUrl;
    api;
    socket;
    currentMethodId = 0;
    methods = [];
    constructor(wsServerUrl, api) {
        super();
        this.wsServerUrl = wsServerUrl;
        this.api = api;
    }
    connect() {
        return new Promise((resolve, reject) => {
            this.disconnect();
            this.socket = new WebSocket(this.wsServerUrl, {
                headers: { Origin: "https://live.vkvideo.ru" },
            });
            this.socket.onopen = async (e) => {
                await this.onOpen(e).catch(reject);
                resolve();
            };
            this.socket.on("message", (data) => {
                if (data.toString("utf8") === "{}") {
                    this.socket?.send("{}", (error) => {
                        if (error) {
                            console.error("[error:websocket]", error);
                        }
                    });
                    return;
                }
            });
            this.socket.onmessage = (e) => this.onMessage(e);
            this.socket.onclose = (e) => this.onClose(e);
            this.socket.onerror = (e) => this.onError(e);
        });
    }
    disconnect() {
        if (this.socket) {
            this.socket.close();
            this.socket.removeAllListeners();
        }
    }
    async onOpen(_) {
        console.log("[open] Initializing connection to live.vkvideo.ru websocket");
        const wsToken = await this.api.getWebSocketConnectToken();
        if (VKPLMessageClient.debugLog) {
            console.warn("[debug:websocket] get websocket token", JSON.stringify(wsToken, null, 5));
        }
        const payload = {
            connect: {
                token: wsToken.token ?? "",
                name: "js",
            },
            id: 0,
        };
        const openResult = await this.invokeMethod(payload);
        console.log("[open] Open result", JSON.stringify(openResult, null, 4));
        console.log("[open] Connected");
    }
    resolveMethod(wsMessage) {
        const methodIndex = this.methods.findIndex((method) => method.id === wsMessage.id);
        if (methodIndex === -1) {
            return;
        }
        const method = this.methods[methodIndex];
        if (!method) {
            return;
        }
        method.callbBack(wsMessage);
        this.methods.splice(methodIndex, 1);
    }
    async invokeMethod(payload) {
        return new Promise((resolve, reject) => {
            this.currentMethodId += 1;
            payload.id = this.currentMethodId;
            if (VKPLMessageClient.debugLog) {
                console.warn("[debug:websocket] invoking live.vkvideo.ru websocket method", JSON.stringify(payload, null, 4));
            }
            this.methods.push({
                id: payload.id,
                callbBack: resolve,
            });
            this.socket?.send(JSON.stringify(payload), (error) => {
                if (error) {
                    reject(error);
                }
            });
        });
    }
    async connectToChat(channel) {
        const paylod = {
            subscribe: {
                channel: `public-chat:${channel.publicWebSocketChannel}`,
            },
            id: 0,
        };
        console.log(`[chat:${channel.blogUrl}] Connecting to channel chat...`);
        const res = await this.invokeMethod(paylod);
        console.log(`[chat:${channel.blogUrl}] Connected to channel chat`);
        return res;
    }
    async connectToReedem(channel, wsSubscribeToken) {
        const paylod = {
            subscribe: {
                channel: `channel-info-manage:${channel.publicWebSocketChannel}`,
                token: wsSubscribeToken,
            },
            id: 0,
        };
        console.log(`[chat:${channel.blogUrl}] Connecting to channel reedem...`);
        const res = await this.invokeMethod(paylod);
        console.log(`[chat:${channel.blogUrl}] Connected to channel reedem`);
        return res;
    }
    async connectToChannelInfo(channel) {
        const paylod = {
            subscribe: {
                channel: `channel-info:${channel.publicWebSocketChannel}`,
            },
            id: 0,
        };
        console.log(`[chat:${channel.blogUrl}] Connecting to channel info...`);
        const res = await this.invokeMethod(paylod);
        console.log(`[chat:${channel.blogUrl}] Connected to channel info`);
        return res;
    }
    onMessage(event) {
        if (event.data === "{}") {
            return;
        }
        let data;
        try {
            data = JSON.parse(event.data);
        }
        catch (error) {
            console.error(error);
            return;
        }
        if (VKPLMessageClient.debugLog) {
            console.warn("[debug:websocket] new message", JSON.stringify(data, null, 4));
        }
        if (this.isWsMethod(data)) {
            this.resolveMethod(data);
        }
        if (this.isWsMessage(data)) {
            this.emit("message", data);
        }
    }
    isWsMethod(message) {
        return (typeof message === "object" && message !== null && "id" in message);
    }
    isWsMessage(message) {
        return (typeof message === "object" &&
            message !== null &&
            "push" in message &&
            typeof message.push === "object" &&
            message.push !== null &&
            "pub" in message.push &&
            typeof message.push.pub === "object" &&
            message.push.pub !== null &&
            "data" in message.push.pub &&
            typeof message.push.pub.data === "object" &&
            message.push.pub.data !== null &&
            "type" in message.push.pub.data);
    }
    async onClose(event) {
        if (event.wasClean) {
            console.log(`[close] Connection closed clean, code=${event.code} reason=${event.reason}`);
            if (event.reason === "no pong") {
                console.log("[close] Reason: no pong");
                console.log("[close] Trying to reconnect...");
                await this.connect();
                this.emit("reconnect");
            }
        }
        else {
            console.error("[close] Connection interrupted");
            console.log("[close] Trying to reconnect...");
            await this.connect();
            this.emit("reconnect");
        }
    }
    onError(error) {
        console.error(`[error]`, error);
    }
}
