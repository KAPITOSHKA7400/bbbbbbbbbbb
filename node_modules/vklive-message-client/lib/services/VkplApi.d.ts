import { EventEmitter } from "eventemitter3";
import { APITypes } from "../types/api.js";
import { HTTPMethod } from "../types/http.js";
import { VKPLClientInternal } from "../types/internal.js";
import { VkplMessageParser } from "./VkplMessageParser.js";
type VkplApiEventMap = {
    refreshed: [token: VKPLClientInternal.TokenAuth];
};
export declare class VkplApi<T extends string> extends EventEmitter<VkplApiEventMap> {
    private messageParser;
    auth?: VKPLClientInternal.TokenAuth | undefined;
    protected readonly baseUrl: string;
    private refreshTokenPromise?;
    private refreshTokenTimeout?;
    constructor(messageParser: VkplMessageParser, auth?: VKPLClientInternal.TokenAuth | undefined, baseUrl?: string);
    protected addAuthorizationHeader(headers: Headers): void;
    /**
     * Получить закреплённое сообщение в чате
     *
     * @param channel - название канала
     */
    getPinMessage(channel: T): Promise<APITypes.PinMessage>;
    /**
     * Перманентно закрепляет сообщение в чате
     *
     * @param channel - название канала
     * @param pinSettings - настройки закрепленного сообщения
     */
    pinMessage(channel: T, pinSettings: APITypes.PinSettings): Promise<{}>;
    /**
     * Обновляет настройки закрплённого сообщения в чате
     *
     * @param channel - название канала
     * @param pinSettings - настройки закрепленного сообщения
     */
    updatePinMessage(channel: T, pinSettings: Omit<APITypes.PinSettings, "messageId">): Promise<{}>;
    /**
     * Удаляет закреплённое сообщение
     *
     * @param channel - название канала
     */
    deletePinMessage(channel: T): Promise<{}>;
    /**
     * Получает список смайлов канала
     *
     * @param channel - название канала
     */
    getSmilesSet(channel: T): Promise<APITypes.TSmilesResponse>;
    /**
     * Получает информацию о блоге
     *
     * @param channel - название канала
     */
    getBlog(channel: T): Promise<APITypes.TBlogResponse>;
    /**
     * Получает информацию о текущем пользователе
     */
    getCurrentUser(): Promise<APITypes.TUser>;
    getWebSocketConnectToken(): Promise<APITypes.TokenResponse>;
    getWebSocketSubscriptionToken(channels: T[]): Promise<APITypes.WebSocketSubscriptionTokensResponse>;
    /**
     * Таймаут пользователя
     *
     * @param channel - название канала
     * @param userId - идентификатор пользователя
     * @param seconds - время таймаута в секундах
     */
    timeoutUser(channel: T, userId: number, seconds: number): Promise<{}>;
    /**
     * Перманентно блокирует пользователя
     *
     * @param channel - название канала
     * @param userId - идентификатор пользователя
     */
    banUser(channel: T, userId: number): Promise<{}>;
    /**
     * Отменяет таймаут и блокировку пользователя
     *
     * @param channel - название канала
     * @param userId - идентификатор пользователя
     */
    unbanUser(channel: T, userId: number): Promise<{}>;
    /**
     * Удаляет все сообщения пользователя из чата канала
     *
     * @param channel - название канала
     * @param userId - идентификатор пользователя
     */
    deleteUserMessages(channel: T, userId: number): Promise<{}>;
    /**
     * Получает статистику пользователя
     *
     * @param channel - название канала
     * @param userId - идентификатор пользователя
     */
    userStats(channel: T, userId: number): Promise<APITypes.UserStatResponse>;
    /**
     * Получает роли, доступные на канале
     *
     * @param channel - название канала
     */
    getChannelRoles(channel: T): Promise<APITypes.ChannelRoleResponse>;
    /**
     * Изменяет роли пользователя
     *
     * @param channel - название канала
     * @param userId - идентификатор пользователя
     * @param roles - список идентификаторов ролей
     */
    setUserRoles(channel: T, userId: number, roles: string[]): Promise<{}>;
    /**
     * Обновляет информацию о стриме
     *
     * @param channel - название канала
     * @param streamInfo - информация о стриме
     *
     * Параметр `title` будет парситься. Возможно использование ссылок.
     * Параметр `plannedAt` будет переведён в UNIX timestamp
     */
    setStreamInfo(channel: T, streamInfo: Partial<VKPLClientInternal.StreamInfo>): Promise<APITypes.ManageStreamResponse>;
    /**
     * Получает список категорий, доступных на live.vkvideo.ru
     *
     * @param filters - Фильтры. Если не указывать фильтры, то возвращает список из всех категорий
     * @return {Promise<APITypes.CategoryResponse>} Ответ API
     */
    getCategories(filters?: Partial<APITypes.CategoryFilters>): Promise<APITypes.CategoryResponse>;
    /**
     * Метод производит поиск категории по названию. Если нашлась категория, то производит
     * изменение категории канала.
     *
     * @param channel - Канал
     * @param categoryName - Название категории
     * @return {Promise<APITypes.ManageStreamResponse>} Ответ API на изменение категории
     *
     * @throws {Error} Если категория не найдена
     */
    setCategory(channel: T, categoryName: string): Promise<APITypes.ManageStreamResponse>;
    /**
     * @param message - Сообщение
     * @param channel - Канал
     * @param mentionUserId - ID пользователей, которые должны быть упомянуты в сообщении
     * @param threadId - ID сообщения, если нужно ответить в конкретной ветке
     * @return {Promise<APITypes.TMessageResponse>} Ответ API на сообщение
     *
     * Позволяет отправлять сообщение в чат трансляции без подключения к чату. Нужно лишь указать канал, куда будет отправлено сообщение
     */
    sendMessage(message: string, channel: T, mentionUsers?: number[], threadId?: number): Promise<APITypes.TMessageResponse>;
    /**
     * @deprecated Vkpl усложнил процесс получения токена по логину и паролю. Поэтому данный функционал временно не работает.
     * При попытке использовать эту функцию, будет выдана ошибка.
     */
    static login(_username: string, _password: string): Promise<APITypes.AuthResponse>;
    static readonly tokenExpiresShift: number;
    isTokenExpired(): boolean;
    refreshToken(): Promise<VKPLClientInternal.TokenAuth>;
    protected httpRequest<T = string>(endpoint: `/${string}`, method: HTTPMethod, query?: URLSearchParams, body?: string | FormData, headers?: Headers): Promise<T | string>;
    private isCantSendError;
}
export {};
//# sourceMappingURL=VkplApi.d.ts.map