import { EventEmitter } from "eventemitter3";
import { CentrifugeClient } from "./services/CentrifugeClient.js";
import { MapApiToClient } from "./services/MapApiToLibService.js";
import { VkplApi } from "./services/VkplApi.js";
import { VkplMessageParser } from "./services/VkplMessageParser.js";
/**
 * @property {string} channels - Список каналов
 * @property {Map} availableSmiles - Список доступных смайлов для акаунта бота
 *
 * Клиента для чата VKPlay Live. Позволяет получать и отправлять сообщения в чат трансляции.
 * Поддерживает несколько каналов, отправку сообщений по каждому из них, добавление упоминаний пользователей, отправку в ветку сообщений.
 *
 * @example
 * const login: string = process.env.VKPL_LOGIN ??;
 * const password: string = process.env.VKPL_PASSWORD;
 * const target: string = process.env.VKPL_TARGET;
 *
 * const client = new VKPLMessageClient({ auth: { login, password }, channels: [target], debugLog: true });
 * await client.connect();
 * await client.sendMessage(target, "Connected to chat!");
 *
 * client.on("message", async (ctx) =>{
 *     if (ctx.message.text.startsWith("!command"))
 *           await ctx.replyToThread("Hello World");
 * });
 */
class VKPLMessageClient extends EventEmitter {
    config;
    wsServerUrl = "wss://pubsub.live.vkvideo.ru/connection/websocket?cf_protocol_version=v2";
    auth;
    credentials;
    /**
     * @property debugLog - Если true, то будет выводить логи вебсокета и API в консоль
     */
    static debugLog;
    static log = true;
    centrifugeClient;
    messageParser;
    channelNames;
    /**
     * @property channels - Список каналов
     */
    channels = [];
    /**
     * @availableSmiles - Список доступных смайлов для акаунта бота
     */
    availableSmiles = new Map();
    api;
    constructor(config) {
        super();
        this.config = config;
        VKPLMessageClient.debugLog = config.debugLog ?? false;
        VKPLMessageClient.log = config.log ?? true;
        if (config.auth && config.auth !== "readonly") {
            if ("accessToken" in config.auth) {
                this.auth = config.auth;
            }
            if ("login" in config.auth) {
                throw new TypeError("VKPLMessageClient: login and password are deprecated. Use accessToken instead");
            }
        }
        this.messageParser = new VkplMessageParser(this.availableSmiles);
        this.api = new VkplApi(this.messageParser, this.auth);
        this.api.on("refreshed", (token) => this.onRefreshToken(token));
        this.channelNames = config.channels;
        this.wsServerUrl = config.wsServer
            ? `${config.wsServer}?cf_protocol_version=v2`
            : this.wsServerUrl;
        this.centrifugeClient = new CentrifugeClient(this.wsServerUrl, this.api);
        this.centrifugeClient.on("message", (message) => this.onCentrifugoMessage(message));
        this.centrifugeClient.on("reconnect", () => this.onReconnect());
    }
    onRefreshToken(token) {
        this.auth = token;
        const ctx = {
            auth: token,
            api: this.api,
        };
        this.emit("refresh-token", ctx);
    }
    isChatMessage(message) {
        return message.push.pub.data.type === "message";
    }
    isRewardMessage(message) {
        return message.push.pub.data.type === "cp_reward_demand";
    }
    isStreamStatusMessage(message) {
        return (message.push.pub.data.type === "stream_start" ||
            message.push.pub.data.type === "stream_end");
    }
    isChannelInfoMessage(message) {
        return message.push.pub.data.type === "stream_online_status";
    }
    isStreamLikeCounterMessage(message) {
        return message.push.pub.data.type === "stream_like_counter";
    }
    isFollower(message) {
        return (message.push.pub.data.type === "actions_journal_new_event" &&
            message.push.pub.data.data.type === "actions_journal_follower");
    }
    onCentrifugoMessage(message) {
        switch (true) {
            case this.isChatMessage(message):
                this.onMessage(message);
                break;
            case this.isRewardMessage(message):
                this.onReward(message);
                break;
            case this.isStreamStatusMessage(message):
                this.onStreamStatus(message);
                break;
            case this.isChannelInfoMessage(message):
                this.onChannelInfo(message);
                break;
            case this.isStreamLikeCounterMessage(message):
                this.onStreamLikeCounter(message);
                break;
            case this.isFollower(message):
                this.onFollower(message);
                break;
        }
    }
    onMessage(message) {
        const channelId = message.push.channel.split(":")[1];
        if (!channelId) {
            return;
        }
        const channel = this.findChannelById(channelId);
        // skip message since we are not subscribed to this channel
        if (!channel) {
            return;
        }
        const mappedMessage = MapApiToClient.chatMessageFromApi(message.push.pub.data, channel);
        const ctx = {
            ...mappedMessage,
            sendMessage: async (text, mentionUsers) => this.api.sendMessage(text, mappedMessage.channel.blogUrl, mentionUsers),
            reply: async (text, mentionUsers) => this.api.sendMessage(text, mappedMessage.channel.blogUrl, mentionUsers
                ? [...mentionUsers, mappedMessage.user.id]
                : [mappedMessage.user.id]),
            replyToThread: async (text, mentionUsers) => this.api.sendMessage(text, mappedMessage.channel.blogUrl, mentionUsers, mappedMessage.id),
            api: this.api,
        };
        this.emit("message", ctx);
        if (VKPLMessageClient.log) {
            console.log(`[chat:${channel.blogUrl}] ${mappedMessage.user.nick}: ${mappedMessage.message.text}`);
        }
    }
    onReward(message) {
        const channelId = message.push.channel.split(":")[1];
        if (!channelId) {
            return;
        }
        const channel = this.findChannelById(channelId);
        // skip message since we are not subscribed to this channel
        if (!channel) {
            return;
        }
        const reward = MapApiToClient.rewardMessageFromApi(message.push.pub.data, channel);
        const ctx = {
            ...reward,
            sendMessage: async (text, mentionUsers) => this.api.sendMessage(text, reward.channel.blogUrl, mentionUsers),
            reply: async (text, mentionUsers) => this.api.sendMessage(text, reward.channel.blogUrl, mentionUsers
                ? [...mentionUsers, reward.user.id]
                : [reward.user.id]),
            api: this.api,
        };
        this.emit("reward", ctx);
        if (VKPLMessageClient.log) {
            console.log(`[reward:${channel.blogUrl}] ${reward.user.nick} reedemed reward: "${reward.reward.name}" ${reward.reward.message ? `with text "${reward.reward.message.text}"` : ""}`);
        }
    }
    onChannelInfo(message) {
        const channelId = message.push.channel.split(":")[1];
        if (!channelId) {
            return;
        }
        const channel = this.findChannelById(channelId);
        // skip message since we are not subscribed to this channel
        if (!channel) {
            return;
        }
        const channelInfo = message.push.pub.data;
        const ctx = {
            ...channelInfo,
            api: this.api,
            sendMessage: async (text, mentionUsers) => this.api.sendMessage(text, channel.blogUrl, mentionUsers),
        };
        this.emit("channel-info", ctx);
        if (VKPLMessageClient.log) {
            console.log(`[channelInfo:${channel.blogUrl}] viewers: ${channelInfo.viewers}, isOnline: ${channelInfo.isOnline}, streamId: ${channelInfo.streamId}`);
        }
    }
    onStreamStatus(message) {
        const channelId = message.push.channel.split(":")[1];
        if (!channelId) {
            return;
        }
        const channel = this.findChannelById(channelId);
        // skip message since we are not subscribed to this channel
        if (!channel) {
            return;
        }
        const streamStatus = message.push.pub.data;
        const ctx = {
            ...streamStatus,
            api: this.api,
            sendMessage: async (text, mentionUsers) => this.api.sendMessage(text, channel.blogUrl, mentionUsers),
        };
        this.emit("stream-status", ctx);
        if (VKPLMessageClient.log) {
            console.log(`[streamStatus:${channel.blogUrl}] ${streamStatus.type}, videoId: ${streamStatus.videoId}`);
        }
    }
    onStreamLikeCounter(message) {
        const channelId = message.push.channel.split(":")[1];
        if (!channelId) {
            return;
        }
        const channel = this.findChannelById(channelId);
        // skip message since we are not subscribed to this channel
        if (!channel) {
            return;
        }
        const likesCount = message.push.pub.data;
        const ctx = {
            ...likesCount,
            api: this.api,
            sendMessage: async (text, mentionUsers) => this.api.sendMessage(text, channel.blogUrl, mentionUsers),
        };
        this.emit("stream-like-counter", ctx);
        if (VKPLMessageClient.log) {
            console.log(`[streamLikeCounter:${channel.blogUrl}] userId: ${likesCount.userId}, counter: ${likesCount.counter}`);
        }
    }
    onFollower(message) {
        const channelId = message.push.channel.split(":")[1];
        if (!channelId) {
            return;
        }
        const channel = this.findChannelById(channelId);
        // skip message since we are not subscribed to this channel
        if (!channel) {
            return;
        }
        const followerInfo = message.push.pub.data.data;
        const ctx = {
            ...followerInfo,
            api: this.api,
            sendMessage: async (text, mentionUsers) => this.api.sendMessage(text, channel.blogUrl, mentionUsers),
        };
        this.emit("follower", ctx);
        if (VKPLMessageClient.log) {
            console.log(`[follower:${channel.blogUrl}] +1 ${followerInfo.follower.displayName}`);
        }
    }
    async onReconnect() {
        await this.connectToChats();
    }
    /**
     * @param id - Идентификатор
     *
     * Возвращает данные канала c API по имени.
     * Поск происходит по каналам, указанным в конфиге
     */
    findChannelById(id) {
        return this.channels.find((channel) => channel.publicWebSocketChannel === id);
    }
    /**
     * @param name - Имя канала
     *
     * Возвращает данные канала c API по имени.
     * Поиск происходит по каналам, указанным в конфиге
     */
    findChannelByName(name) {
        return this.channels.find((channel) => channel.blogUrl === name);
    }
    async connectToChats() {
        for (const channel of this.channels) {
            try {
                await this.centrifugeClient.connectToChat(channel);
                await this.centrifugeClient.connectToChannelInfo(channel);
                if (!this.auth) {
                    continue;
                } // can't connect to rewards without token
                const wsSubscribeToken = await this.api.getWebSocketSubscriptionToken([
                    channel.publicWebSocketChannel,
                ]);
                if (!wsSubscribeToken.data.tokens.length) {
                    throw new Error(`Failed to obtain websocket subscribe token for reward channel: ${channel.blogUrl}
Connect to reward channel will be skipped`);
                }
                await this.centrifugeClient.connectToReedem(channel, wsSubscribeToken.data.tokens[0]?.token ?? "");
            }
            catch (error) {
                console.error(error);
            }
        }
    }
    async obtainToken() {
        if (!this.credentials) {
            throw new TypeError("Credentials must be provided to obtain token");
        }
        const token = await VkplApi.login(this.credentials.login, this.credentials.password);
        if (token.accessToken) {
            this.auth = token;
            this.api.auth = token;
        }
    }
    isAuthReadOnly() {
        return this.config.auth === "readonly" || !this.config.auth;
    }
    /**
     * Подключает бота к каналам, которые были переданы в конфиг
     * Необходимо вызвать этот метод, если вы хотите, чтобы бот получал сообщения
     */
    async connect() {
        if (!this.auth && this.credentials) {
            await this.obtainToken();
        }
        for (const channelName of this.channelNames) {
            const channel = MapApiToClient.channelFromBlogResponse(await this.api.getBlog(channelName));
            this.channels.push(channel);
        }
        if (!this.isAuthReadOnly()) {
            await this.populateMessageParserWithSmiles();
        }
        await this.centrifugeClient.connect();
        await this.connectToChats();
    }
    disconnect() {
        this.centrifugeClient.disconnect();
        this.centrifugeClient.removeAllListeners();
    }
    async populateMessageParserWithSmiles() {
        if (this.auth) {
            const channel = this.channels[0];
            if (!channel) {
                return;
            }
            const smilesSet = await this.api.getSmilesSet(channel.blogUrl);
            if (VKPLMessageClient.debugLog)
                console.warn("[debug:chat] Get smiles set", JSON.stringify(smilesSet, null, 5));
            for (const set of smilesSet.data.sets)
                for (const smile of set.smiles)
                    this.availableSmiles.set(smile.name, smile.id);
        }
        else {
            throw new Error("[chat] Cannot get list of smiles because of no auth token nor channels provided");
        }
    }
    /**
     * @param message - Сообщение
     * @param channel - Канал
     * @param mentionUserId - ID пользователей, которые должны быть упомянуты в сообщении
     * @param threadId - ID сообщения, если нужно ответить в конкретной ветке
     * @return {Promise<APITypes.TMessageResponse>} Ответ API на сообщение
     *
     * Позволяет отправлять сообщение в чат трансляции без подключения к чату. Нужно лишь указать канал, куда будет отправлено сообщение
     *
     * @deprecated Используйте `client.api.sendMessage` вместо `client.sendMessage`
     */
    async sendMessage(message, channel, mentionUserId, threadId) {
        if (this.isAuthReadOnly()) {
            throw new Error("You must provide auth token or credentials. Current mode is readonly");
        }
        if (!this.auth) {
            throw new Error("You must provide auth token or credentials");
        }
        return this.api.sendMessage(message, channel, mentionUserId, threadId);
    }
}
export default VKPLMessageClient;
