import { VkplApi } from "../services/VkplApi.js";
import { APITypes } from "./api.js";
import { VkWsTypes } from "./api.v2.js";
export declare namespace VKPLClientInternal {
    type Smile = {
        id: string;
        name: string;
    };
    type AccessTokenAuth = {
        accessToken: string;
    };
    type WithRefreshToken<T extends Record<string, unknown>> = {
        refreshToken: string;
        expiresAt: number;
        clientId: string;
    } & T;
    type TokenAuth = AccessTokenAuth | WithRefreshToken<AccessTokenAuth>;
    /**
     * @deprecated Vkpl усложнил процесс получения токена по логину и паролю. Поэтому данный функционал временно не работает.
     * При попытке использовать эту функцию, будет выдана ошибка.
     */
    type LoginAuth = {
        login: string;
        password: string;
    };
    type ReadonlyAuth = "readonly" | undefined;
    type Auth = TokenAuth | LoginAuth | ReadonlyAuth;
    type Config<T extends string> = {
        channels: T[];
        auth?: Auth;
        wsServer?: string;
        debugLog?: boolean;
        log?: boolean;
    };
    type Channel = {
        blogUrl: string;
        publicWebSocketChannel: string;
        name: string;
        id: number;
    };
    type ParentMessage = {
        message: DeserializedMessage;
        user: VkWsTypes.ChatUser;
        id: number;
        isPrivate: boolean;
    };
    type ChatMessage = {
        parent?: ParentMessage;
        message: DeserializedMessage;
        user: VkWsTypes.ChatUser;
        channel: Channel;
        createdAt: number;
        id: number;
        isPrivate: boolean;
        flags: VkWsTypes.MessageFlags;
        threadId: string | null;
    };
    type DeserializedMessage = {
        text: string;
        smiles: Smile[];
        mentions: Mention[];
        links: Link[];
    };
    type Link = {
        text: string;
        url: string;
    };
    type Mention = {
        userId: number;
        name?: string;
        displayName?: string;
        nick?: string;
    };
    type Role = {
        id: string;
        name: string;
        priority: number;
        smallUrl: string;
        mediumUrl: string;
        largeUrl: string;
    };
    type Badge = {
        achievement: {
            name: string;
            type: string;
        };
        id: string;
        isCreated: boolean;
        largeUrl: string;
        mediumUrl: string;
        name: string;
        smallUrl: string;
    };
    type StreamInfo = {
        title: string;
        categoryId: string;
        plannedAt: Date;
        donationAlertNick: string;
        subscriptionLevelId: string;
    };
    type Context<Channel extends string> = {
        api: VkplApi<Channel>;
    };
    type MessageEvent<Channel extends string> = [
        ctx: MessageEventContext<Channel>
    ];
    type MessageEventContext<Channel extends string> = Context<Channel> & ChatMessage & {
        /**
         * Отправить сообещние в канал
         */
        sendMessage(text: string, mentionUsers?: number[]): Promise<APITypes.TMessageResponse>;
        /**
         * Отметить пользователя в сообщении, и отправить его
         */
        reply(text: string, mentionUsers?: number[]): Promise<APITypes.TMessageResponse>;
        /**
         * Отправить сообщение в тред
         */
        replyToThread(text: string, mentionUsers?: number[]): Promise<APITypes.TMessageResponse>;
    };
    type RewardMessage = {
        /**
         * Полученная награда
         */
        reward: VkWsTypes.Reward & {
            /**
             * Сообщение к награде
             */
            message?: DeserializedMessage;
            /**
             * Статус награды
             */
            status: VkWsTypes.RewardStatus;
        };
        /**
         * Канал, в котором была получена награда
         */
        channel: Channel;
        /**
         * Пользователь, который получил награду
         */
        user: VkWsTypes.User;
    };
    type RewardEvent<Channel extends string> = [
        ctx: RewardEventContext<Channel>
    ];
    type RewardEventContext<Channel extends string> = Context<Channel> & RewardMessage & {
        /**
         * Отправить сообещние в канал
         */
        sendMessage(text: string, mentionUsers?: number[]): Promise<APITypes.TMessageResponse>;
        /**
         * Отметить пользователя в сообщении, и отправить его
         */
        reply(text: string, mentionUsers?: number[]): Promise<APITypes.TMessageResponse>;
    };
    type ChannelInfoEvent<Channel extends string> = [
        ctx: ChannelInfoEventContext<Channel>
    ];
    type ChannelInfoEventContext<Channel extends string> = Context<Channel> & VkWsTypes.ChannelInfo & {
        /**
         * Отправить сообещние в канал
         */
        sendMessage(text: string, mentionUsers?: number[]): Promise<APITypes.TMessageResponse>;
    };
    type StreamStatusEvent<Channel extends string> = [
        ctx: StreamStatusEventContext<Channel>
    ];
    type StreamStatusEventContext<Channel extends string> = Context<Channel> & VkWsTypes.StreamStatus & {
        /**
         * Отправить сообещние в канал
         */
        sendMessage(text: string, mentionUsers?: number[]): Promise<APITypes.TMessageResponse>;
    };
    type RefreshTokenEvent<Channel extends string> = [
        ctx: RefreshTokenEventContext<Channel>
    ];
    type RefreshTokenEventContext<Channel extends string> = Context<Channel> & {
        auth: TokenAuth;
    };
    type StreamLikeCounterEventContext<Channel extends string> = Context<Channel> & VkWsTypes.StreamLikeCounter & {
        /**
         * Отправить сообещние в канал
         */
        sendMessage(text: string, mentionUsers?: number[]): Promise<APITypes.TMessageResponse>;
    };
    type StreamLikeCounterEvent<Channel extends string> = [
        ctx: StreamLikeCounterEventContext<Channel>
    ];
    type FollowerEventContext<Channel extends string> = Context<Channel> & VkWsTypes.ActionsJournalFollower & {
        /**
         * Отправить сообещние в канал
         */
        sendMessage(text: string, mentionUsers?: number[]): Promise<APITypes.TMessageResponse>;
    };
    type FollowerEvent<Channel extends string> = [
        ctx: FollowerEventContext<Channel>
    ];
}
//# sourceMappingURL=internal.d.ts.map